#                                           ** Импорт встроенных библиотек **
# ----------------------------------------------------------------------------------------------------------------------
import os
import datetime
from typing import Dict
import re
#                                           ** Импорт сторонних библиотек **
# ----------------------------------------------------------------------------------------------------------------------
import pandas as pd
from pandas.io.excel import ExcelWriter
import openpyxl
import requests
from bs4 import BeautifulSoup
from joblib import dump  # модуль сохранения и вызва фреймов данных из другого файла
from joblib import load  # модуль сохранения и вызва фреймов данных из другого файла
import time
#                                                ** Импорт модулей **
# ----------------------------------------------------------------------------------------------------------------------
from globals import project_home_directory  # - импорт глобальных переменных
# ----------------------------------------
from src.parser.parsing_sets import *
from src.data_join.df_konstruktor import *
from src.data_join.damps import *
from src.user_module.path_joiner import *
from src.user_module.dialog import pars_or_load
from src.data_join.protocol import *
from src.coordinates.coordinate_data import insert_lat_lon

# ======================================================= run ==========================================================
"""
Исполнительный файл проекта.
В этом модуле реализован процесс запуска и взаимодействия с внешней средой.
Главный модуль проекта. Собирает все функции и переменные последовательную в конструкцию, но ничего не выполняет.
"""
# ======================================================= run ==========================================================
# ----------------------------------------------------------------------------------------------------------------------
#                                         *** Определение исходных данных ***
# ----------------------------------------------------------------------------------------------------------------------
project_directory = os.path.join(r'\data', 'save_damp' + '\\')  # Директория сохранения дампа и протокола (по умолчанию)
# Нужен еще слеш в конце, не хватает!! - (+ '\\')
path_save_damp: str = get_path(project_directory, project_home_directory, default_path=True)
path_save_protocol: str = get_path(project_directory, project_home_directory, default_path=True)
# ----------------------------------------------------------------------------------------------------------------------
input_list_url: dict[str, str] = {  # создадим словарь с перечнем url и именами корпораций:
    # 'dns': 'https://bitovayatehnika.ru/magaziny/dns',
    # 'mvideo': 'https://bitovayatehnika.ru/magaziny/mvideo',
    # 'eldorado': 'https://bitovayatehnika.ru/magaziny/eldorado',
    'kcentr': 'https://bitovayatehnika.ru/magaziny/korporaciya-centr',
    # 'rbt': 'https://bitovayatehnika.ru/magaziny/rbt'
}


# ===================================================== parser =========================================================
def parsing_sets_group(input_list_url: dict[str, str], project_directory: str, path_save_damp: str,
                       path_save_protocol: str):
    """
    Объединенная функция работы парсера
    :param input_list_url: Список исходных ссылок для работы парсера, defaults to None
    :param project_directory: Директория сохранения дампа и протокола (по умолчанию), defaults: '\data\save_damp\'
    :param path_save_damp: Полный путь без указания файла к дампу.
    :param path_save_protocol: Полный путь без указания файла к дампу.
    :return:
    """

    start_parser = time.perf_counter()
    print(
        f'============================================================================================================================================\n'
        f'                                                            Запуcк парсинг модуля...\n'
        f'================================================================== parser ==================================================================\n'
        f'                                                                    ***')
    for i in input_list_url:  # Переборка циклом значений словаря
        # print(i, input_list_url[i]) # Результат. Переборка циклом значений словаря
        # start = time.monotonic_ns() #-время в нано секундах
        # perf_counter_ns() - int. - целые секунды
        # --------------------------------------------------------------------------------------------------------------
        #
        #                                                   ***
        #
        # ================================================ parser ======================================================
        # --------------------------------------------------------------------------------------------------------------
        #                                                       * Работа парсинг модуля: parsing_sets *
        # --------------------------------------------------------------------------------------------------------------
        start = time.perf_counter()  # -время в секундах
        soup: object = get_soup(
            input_list_url[i])  # Получаем первичный "суп" из тегов по ссылке (парсинг).
        finish = time.perf_counter()
        print(
            f'============================================================================================================================================\n'
            f'Супчик из тегов для {i} готов! Затраченное время: ' + str(round((finish - start), 2)))
        # ------------------------------------------------
        start = time.perf_counter()
        city_name_list: list = get_city_name_list(soup)  # Получаем список городов присутствия (парсинг).
        finish = time.perf_counter()
        print(
            f'--------------------------------------------------------------------------------------------------------------------------------------------\n'
            f'Список городов {i} готов! Затраченное время: ' + str(round((finish - start), 2)))
        # ------------------------------------------------
        start = time.perf_counter()
        city_url_list: list = get_city_url_list(soup)  # Получаем список url адресов филиалов (парсинг). city_url_list
        finish = time.perf_counter()
        print(
            f'--------------------------------------------------------------------------------------------------------------------------------------------\n'
            f'Список url адресов городов {i} готов! Затраченное время: ' + str(round((finish - start), 2)))
        # ------------------------------------------------
        start_multi = time.perf_counter()
        print(
            f'--------------------------------------------------------------------------------------------------------------------------------------------\n'
            f'Началась работа мульти-страничного поиска адресов филиалов для {i}. Это займет какое-то время:')
        address_list: list = get_address_list(
            city_url_list, corp_name_prefix=i)  # Мульти-страничный поиск адресов филиалов магазинов (парсинг).
        finish_multi = time.perf_counter()
        time_delt = (finish_multi - start_multi)
        s = round((time_delt % 3600), 2)  # секунды
        m = time_delt // 60  # минуты
        print(
            f'Мульти-страничный поиск адресов для {i} отработал! Затраченное время: {m} мин. {s} сек.')
        # --------------------------------------------------------------------------------------------------------------
        #                                                        * Работа дата фрейм модуля: df_konstruktor *
        # --------------------------------------------------------------------------------------------------------------
        start = time.perf_counter()
        df_city = get_df_city(city_name_list, city_url_list,
                              corp_name_prefix=i)  # - Создаем датафрейм с наименованием горов + URL
        finish = time.perf_counter()
        print(f'Датафрейм: "Список городов {i}" готов! Затраченное время: ' + str(round((finish - start), 2)))
        # ------------------------------------------------
        # name_columns_city: str = 'city_name', name_columns_url: str = 'url - in get_df_city() to defaults.
        start = time.perf_counter()
        df_address = get_df_address(address_list, corp_name_prefix=i)  # Значения ключей словаря в corp_name_prefix.
        finish = time.perf_counter()
        # name_columns_address: str = 'addresses_stores' - in get_df_address() to defaults.
        print(f'Датафрейм: "Список адресов {i}" готов! Затраченное время: ' + str(round((finish - start), 2)))
        # --------------------------------------------------------------------------------------------------------------
        #
        #                                                     ***
        #
        # ================================================ data_join ===================================================
        # --------------------------------------------------------------------------------------------------------------
        #                                                        * Работа модуля сохранения/загрузки данных: damps *
        # --------------------------------------------------------------------------------------------------------------
        start = time.perf_counter()
        save_damp(path_save_protocol, path_save_damp, df_city, name_damp="city_table", corp_name_prefix=i)
        finish = time.perf_counter()
        print(f'Датафрейм: "Список городов {i}" сохранен в дамп! Затраченное время: ' + str(round((finish - start), 2)))
        # ------------------------------------------------
        start = time.perf_counter()
        save_damp(path_save_protocol, path_save_damp, df_address, name_damp='addres_table', corp_name_prefix=i)
        finish = time.perf_counter()
        print(f'Датафрейм: "Список адресов {i}" сохранен в дамп! Затраченное время: ' + str(round((finish - start), 2)))
    # --------------------------------------------------------------------------------------------------------------
    finish_parser = time.perf_counter()
    time_delt_parser = (finish_parser - start_parser)
    s = round((time_delt % 3600), 2)  # секунды
    m = time_delt // 60  # минуты
    return print(f'Парсер завершил работу. Общее время парсинга всех корпораций составило: {m} мин. {s} сек.')
    # --------------------------------------------------------------------------------------------------------------
    # ================================================ parser ======================================================


# ===================================================== parser =========================================================
# =====================================================  user  =========================================================
# Модуль взаимодействия с Юзером:
# ----------------------------------------------------------------------------------------------------------------------
print(
    f'==================================================================== *** ===================================================================\n'
    f'                                             *   ЗАПУЩЕНА ПРОГРАММА РАБОТЫ С ДАННЫМИ О КОНКУРЕНТАХ ДНС   *\n'
    f'==================================================================== *** ===================================================================')
# ----------------------------------------------------------------------------------------------------------------------
input_value = pars_or_load()  # Диалог: выбери парсинг или загрузку старых данных.
if input_value == '1':
    parsing_sets_group(input_list_url, project_directory, path_save_damp, path_save_protocol)  # запускает парсер
else:  # Цикл загружает поочередно дампы в переменные

    for b, s in enumerate(input_list_url, 1):  # Переборка циклом значений словаря
        # load_damp(path_save_protocol, corp_name_prefix='dns')
        if b == 1:
            damp_one = read_protocol(path_save_protocol, corp_name_prefix=s)
            continue
        if b == 2:
            damp_two = read_protocol(path_save_protocol, corp_name_prefix=s)
            continue
        if b == 3:
            damp_three = read_protocol(path_save_protocol, corp_name_prefix=s)
            continue
        if b == 4:
            damp_four = read_protocol(path_save_protocol, corp_name_prefix=s)
            continue
        # if b == 5:
        #     damp_five = read_protocol(path_save_protocol, corp_name_prefix=s)

#   todo: добавить исключение ошибки при загрузке дампа (если нет такого дампа то следующий
#    продумать смещение для чтения записей протокола (что еще читал запись о сити тейбл
# damp_four.info
# ----------------------------------------------------------------------------------------------------------------------
print(damp_one.head)
print(insert_lat_lon(damp_one))
print(damp_one.info())  # переводим адрес в координаты
# print(damp_three.iloc[64])  # Корпорация Центр Ижевск, ул. Пушкинская, 130 - только этот отработал

# print(insert_lat_lon(damp_four))
# damp_five
# print(damp_four.info)  # .iloc[64])
# ----------------------------------------------------------------------------------------------------------------------
#                               *** Передача входных данных для запуска цикла программы ***
# ----------------------------------------------------------------------------------------------------------------------
#   todo: модуль принимающий ввод от пользователя имен корпораций и url на будущее

#   todo: а так через чтение эксель файла. Добавить условие или или + добавление записи д/ля поиска.
#  todo: Диалоговое огно или ветвление нужно ли сохранить в другую директорию (вытащить на верх)
#  todo: + куда сохранить протокол загрузки (уточнить) (вывести в диалоговое окно)
#   пока что по умолчанию в пааку сохранения дампа
#   надо делать клас для модуля сохранения дампа, что бы вызывать метод save_protocol и передавать ему значение
#   todo:  взаимодействие с пользователем: ввести диалог: сохранять ли в эксель? - выполнять сохранение в эксель
# todo: после сохранения в дамп. и для сохранения в эксель - загружать дамп

# todo: выполнять парсинг цикл, только по времени или по команде, вставить условие времени
# todo: Добавить модуль отложенного запуска по времени
# фиксируем время старта работы кода
# Без плюса обрежет путь D:\data\save_damp\protocol.xlsx
# todo: Сделать модуль изменения дирректории: написать функцией и засуннуть внутрь сейф дамп!
# path_protocol: str = path_save_damp + r'\protocol.xlsx'  # = \data\save_damp\protocol.xlsx
# name_file  # name_protocol = 'protocol'
# path_save_damp: str = os.path.join(r'\data', 'save_damp')  # =\data\save_damp
# path_save_protocol = os.path.join(project_home_directory + r'\data', 'save_damp', f'{name_protocol}.xlsx')
